<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1" />
  <title>Endless Runner — Any Screen (Mobile Fix)</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0f1a; color: #e8f0ff; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
    .wrap { display:block; height:100%; }
    canvas { background: transparent; width: 100vw; height: 100vh; border-radius: 0; box-shadow: none; touch-action: none; display:block; }
    .hud { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); display:flex; gap:12px; background: rgba(0,0,0,.35); padding:8px 12px; border-radius: 12px; backdrop-filter: blur(6px); font-weight:600; z-index:2; }
    .btnbar { position: fixed; bottom: 12px; left: 50%; transform: translateX(-50%); display:flex; gap:10px; z-index: 9999 !important; }
    button { background:#111a2d; color:#e8f0ff; border:1px solid #223; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; }
    .overlay { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index:3; }
    .overlay.show { display:flex; }
    .card { background: rgba(0,0,0,.55); padding: 18px 22px; border-radius: 14px; text-align:center; box-shadow: 0 6px 30px rgba(0,0,0,.5); }
  
/* === Debug HUD === */
.debugHud { 
  position: fixed; top: 8px; left: 8px; z-index: 99999; 
  font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  background: rgba(0,0,0,.55); 
  color: #cfe8ff; 
  padding: 8px 10px; 
  border: 1px solid rgba(255,255,255,.1); 
  border-radius: 10px;
  pointer-events: none;
  white-space: pre;
}
.hidden { display: none !important; }
.debugBadge {
  position: fixed; top: 8px; right: 8px; 
  z-index: 99999; 
  background: rgba(0,0,0,.55); color: #9cffb2;
  font: 11px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  border: 1px solid rgba(255,255,255,.1);
  border-radius: 999px; padding: 4px 8px;
  pointer-events: none;
}

</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="1280" height="720"></canvas>
    <div class="btnbar">
      <button id="jumpBtn">Jump</button>
      <button id="restartBtn">Restart</button>
          <button id="debugBtn" aria-label="Toggle debug (FPS/DPR/hitboxes)">Debug</button>
    </div>
        <button id="debugBtn" aria-label="Toggle debug (FPS/DPR/hitboxes)">Debug</button>
    </div>
  <div class="hud" id="hud">
    <div>Score: <span id="score">0</span></div>
    <div>Best: <span id="best">0</span></div>
  </div>
  <div class="overlay" id="overlay">
    <div class="card">
      <h2>Game Over</h2>
      <p>Tap / click <strong>Restart</strong> or press <strong>R</strong>.</p>
      <small>Double-jump enabled — tap again while airborne.</small>
    </div>
  </div>
  <script>
    const SPRITE_META = {
      frameWidth:  1400,
      frameHeight: 1400,
      frames:      28,
      imagePath:   \"./assets/sprite.png\"
    };

    const sprite = new Image(); sprite.crossOrigin = 'anonymous'; sprite.src = SPRITE_META.imagePath;
    const bgImg = new Image(); bgImg.crossOrigin = 'anonymous'; bgImg.src = \"./assets/bg.png\"; let bgReady = false; bgImg.onload = () => { bgReady = true; };

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));

    function groundHeight(){ return Math.max(90 * DPR, Math.floor(canvas.height * 0.15)); }
    const FLOOR_Y = () => canvas.height - groundHeight();

    const GRAVITY = 0.9;
    let JUMP
    // Responsive baselines and last-known canvas size for proportional rescaling
    const BASE_WIDTH = 1280, BASE_HEIGHT = 720;
    let lastCanvasW = canvas.width || BASE_WIDTH;
    let lastCanvasH = canvas.height || BASE_HEIGHT;
    _VELOCITY = -18.5; // will be recomputed for screen size
    const PLAYER_X = () => Math.floor(canvas.width * 0.2);
    const SCROLL_SPEED_START = 9;
    const SPEED_INCREASE = 0.00025;
    const SPAWN_MIN = 65, SPAWN_MAX = 140;
    const RUN_FPS = 70, AIR_FPS = 40, ANIM_SPEED_BOOST = 0.35;
    const HITBOX_SHRINK = 0.78;

    let state = 'playing', t = 0, speed = SCROLL_SPEED_START, score = 0;
    // Asset readiness flags for diagnostics
    window.sprReady = false; window.bgReady = false;


    // === Debug HUD state ===
    let DEBUG = false;
    let fps = 0, lastTs = performance.now();
    const debugHud = document.getElementById('debugHud');
    const debugBadge = document.getElementById('debugBadge');

    function toggleDebug(force) {
      DEBUG = (typeof force === 'boolean') ? force : !DEBUG;
      if (DEBUG) { debugHud.classList.remove('hidden'); debugBadge.classList.remove('hidden'); }
      else { debugHud.classList.add('hidden'); debugBadge.classList.add('hidden'); }
    }
    let best = Number(localStorage.getItem('runner_best')||0);
    document.getElementById('best').textContent = best;

    const player = {
      x: 0, y: 0, vy: 0, onGround: true, frame: 0, frameTimer: 0,
      jumpCount: 0, maxJumps: 2,
      w: Math.floor(SPRITE_META.frameWidth * 1.0 * DPR),
      h: Math.floor(SPRITE_META.frameHeight * 1.0 * DPR),
      update() {
        this.vy += GRAVITY * DPR;
        this.y += this.vy * DPR;
        // Ceiling clamp (~1% from top) to keep player in view
        const ceiling = Math.floor(canvas.height * 0.05);
        if (this.y < ceiling) { this.y = ceiling; if (this.vy < 0) this.vy = 0; }
        const groundY = FLOOR_Y() - this.h + Math.floor(canvas.height*0.13);
        if (this.y >= groundY) { this.y = groundY; this.vy = 0; this.onGround = true; this.jumpCount = 0; } else { this.onGround = false; }
        // Animate both states
        this.frameTimer += 1;
        const targetFps = (this.onGround ? RUN_FPS : AIR_FPS);
        if (this.frameTimer >= (60 / targetFps)) { this.frameTimer = 0; this.frame = (this.frame + 1) % SPRITE_META.frames; }
      },
      jump() { if (this.onGround || this.jumpCount < this.maxJumps) { this.vy = JUMP_VELOCITY * DPR; this.onGround = false; this.jumpCount++; } },
      draw() { const sx = this.frame; ctx.drawImage(sprite, sx * SPRITE_META.frameWidth, 0, SPRITE_META.frameWidth, SPRITE_META.frameHeight, this.x, this.y, this.w, this.h); },
      hitbox() { const sw = this.w * HITBOX_SHRINK; const sh = this.h * HITBOX_SHRINK; return { x: this.x+(this.w-sw)/2, y: this.y+(this.h-sh)/3, w: sw, h: sh }; }
    };

    function onResizeRecompute() {
      const available = FLOOR_Y();
      const targetH = Math.max(64 * DPR, Math.floor(available * 0.38));
      const aspect = SPRITE_META.frameWidth / SPRITE_META.frameHeight;
      player.h = targetH;
      player.w = Math.floor(targetH * aspect);
      if (player.onGround) player.y = FLOOR_Y() - player.h + Math.floor(canvas.height*0.13);
      player.x = PLAYER_X();
    }

    function recomputePhysics() {
      const available = FLOOR_Y();
      const desiredApex = Math.max(available * 0.42, 80 * DPR); // ~42% of play area
      const gEff = GRAVITY * DPR;
      JUMP_VELOCITY = -Math.sqrt(Math.max(2 * gEff * desiredApex, 1));
    }

    const obstacles = []; let spawnTimer = 90;
    
    function obstacleDims(){
      // Obstacles scale with canvas height; widths vary slightly
      const hUnit = Math.max(0.06 * canvas.height, 24 * DPR);
      const height = Math.floor(hUnit * (0.9 + Math.random() * 0.6));   // ~6–10% of height
      const width  = Math.floor(height * (0.7 + Math.random() * 0.5));  // aspect 0.7–1.2
      return { width, height };
    }
                  ; }
    
    function spawnObstacle(){
      const d = obstacleDims();
      const x = Math.floor(canvas.width + (Math.random() * canvas.width * 0.15));
      const y = Math.floor(FLOOR_Y() - d.height + Math.floor(canvas.height*0.13));
      obstacles.push({ x, y, w: d.width, h: d.height, color: '#2bd1ff' });
    }
                  ); }

    function drawBackground() {
      if (!bgReady) return;
      const sourceW = bgImg.width;
      const sourceH = bgImg.height; // crop bottom 15%
      const coverScale = Math.max(canvas.width / sourceW, canvas.height / sourceH);
      const dw = Math.ceil(sourceW * coverScale);
      const dh = Math.ceil(sourceH * coverScale);
      const dy = Math.floor((canvas.height - dh) / 2);
      const speeds = [0.12, 0.28, 0.5];
      const alphas = [0.6, 0.85, 1];
      for (let li = 0; li < speeds.length; li++) {
        const offset = Math.floor((-t * speed * speeds[li]) % dw);
        ctx.save(); ctx.globalAlpha = alphas[li];
        let x = offset - dw;
        while (x < canvas.width) { ctx.drawImage(bgImg, 0, 0, sourceW, sourceH, Math.floor(x), Math.floor(dy), dw, dh); x += dw; }
        ctx.restore();
      }
    }

    function drawGround() { /* removed road layer per request */ }
    }

    function rectsIntersect(a,b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function update() {
      if (state !== 'playing') return;
      t++; speed += 0.00025 * DPR;
      player.update();
      spawnTimer--; if (spawnTimer <= 0) { spawnObstacle(); spawnTimer = Math.floor(65 + Math.random() * (140 - 65)); }
      for (let i = obstacles.length - 1; i >= 0; i--) { const o = obstacles[i]; o.x -= speed * DPR; if (o.x + o.w < 0) { obstacles.splice(i,1); score += 1; document.getElementById('score').textContent = score; } }
      const hb = player.hitbox(); for (const o of obstacles) { if (rectsIntersect(hb, o)) { die(); break; } }
    }

    function draw() { ctx.clearRect(0,0,canvas.width,canvas.height); if (window.sprReady !== true || window.bgReady !== true) { ctx.save(); ctx.fillStyle = 'rgba(0,0,0,.65)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle = '#cfe8ff'; ctx.font = (18*DPR)+'px ui-monospace,monospace'; ctx.textAlign='center'; ctx.fillText('Loading assets… (Sprite: '+window.sprReady+'  BG: '+window.bgReady+')', canvas.width/2, canvas.height/2); ctx.restore(); return; }
      drawBackground(); drawGround(); for (const o of obstacles) { ctx.fillStyle = 'rgba(43,209,255,.2)'; ctx.fillRect(o.x, o.y, o.w, o.h); ctx.strokeStyle = '#2bd1ff'; ctx.lineWidth = 3 * DPR; ctx.strokeRect(o.x, o.y, o.w, o.h); 
      // === DEBUG overlays ===
      if (DEBUG) {
        // Player hitbox
        const phb = player.hitbox();
        ctx.save();
        ctx.lineWidth = 2 * DPR;
        ctx.strokeStyle = 'rgba(0,255,120,.9)';
        ctx.strokeRect(Math.floor(phb.x), Math.floor(phb.y), Math.floor(phb.w), Math.floor(phb.h));
        // Obstacles hitboxes
        ctx.strokeStyle = 'rgba(255,60,0,.9)';
        for (const o of obstacles) {
          ctx.strokeRect(Math.floor(o.x), Math.floor(o.y), Math.floor(o.w), Math.floor(o.h));
        }
        ctx.restore();
      }

      // Update debug HUD contents
      if (DEBUG) {
        const lines = [
          `FPS: ${Math.round(fps)}`,
          `DPR: ${DPR}`,
          `Speed: ${speed.toFixed(2)}`,
          `Score: ${score}`,
          `Obstacles: ${obstacles.length}`,
          `GroundY(px): ${FLOOR_Y()}`,
        ];
        debugHud.textContent = lines.join('
');
      }

    }player.draw(); }

    function loop() { const now = performance.now(); const dt = now - lastTs; lastTs = now; fps = fps ? (fps*0.9 + (1000/dt)*0.1) : (1000/dt);
      update(); draw(); requestAnimationFrame(loop); }
    function reset() { state = 'playing'; t = 0; speed = 9; score = 0; document.getElementById('score').textContent = '0'; obstacles.length = 0; spawnTimer = 90; onResizeRecompute(); recomputePhysics(); player.x = PLAYER_X(); player.y = FLOOR_Y() - player.h + Math.floor(canvas.height*0.03); player.vy = 0; player.onGround = true; player.frame = 0; document.getElementById('overlay').classList.remove('show'); }
    function die() { state = 'dead'; best = Math.max(best, score); localStorage.setItem('runner_best', best); document.getElementById('best').textContent = best; document.getElementById('overlay').classList.add('show'); }

    function resizeCanvas() { const vw = (window.visualViewport && window.visualViewport.width) ? window.visualViewport.width : window.innerWidth; const vh = (window.visualViewport && window.visualViewport.height) ? window.visualViewport.height : window.innerHeight; canvas.style.width = vw + 'px'; canvas.style.height = vh + 'px'; DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1)); canvas.width = Math.floor(vw * DPR); canvas.height = Math.floor(vh * DPR); ctx.imageSmoothingEnabled = false; onResizeRecompute(); recomputePhysics(); 
      // === Responsive rescale of positions/sizes ===
      const newW = canvas.width, newH = canvas.height;
      const sx = (lastCanvasW > 0) ? (newW / lastCanvasW) : 1;
      const sy = (lastCanvasH > 0) ? (newH / lastCanvasH) : 1;

      // Scale player dimensions & position
      if (!Number.isFinite(player.w) || !Number.isFinite(player.h)) { player.w = Math.floor(SPRITE_META.frameWidth * DPR); player.h = Math.floor(SPRITE_META.frameHeight * DPR); }
      player.w = Math.max(1, Math.floor(player.w * sy));  // scale by height for character size
      player.h = Math.max(1, Math.floor(player.h * sy));
      player.x = Math.floor(player.x * sx);
      player.y = Math.floor(player.y * sy);

      // Scale speed horizontally so scrolling feels similar
      if (typeof speed === 'number') speed = speed * sx;

      // Scale all existing obstacles
      if (Array.isArray(obstacles)) {
        for (const o of obstacles) {
          o.x = Math.floor(o.x * sx);
          o.y = Math.floor(o.y * sy);
          o.w = Math.max(1, Math.floor(o.w * sx));
          o.h = Math.max(1, Math.floor(o.h * sy));
        }
      }

      // Recompute physics (jump velocity depends on height/DPR)
      if (typeof recomputePhysics === 'function') recomputePhysics();

      // Re-align player to floor if needed
      const gY = FLOOR_Y() - player.h + Math.floor(canvas.height*0.13);
      if (player.y > gY) { player.y = gY; player.vy = 0; player.onGround = true; }

      // Update last-known size
      lastCanvasW = newW; lastCanvasH = newH;
    
    }
    new ResizeObserver(resizeCanvas).observe(document.body);

    function jump() { player.jump(); }
    window.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') jump(); if (e.key.toLowerCase() === 'r') reset(); });
    document.getElementById('jumpBtn').addEventListener('click', jump);
    document.getElementById('restartBtn').addEventListener('click', reset);
    
    
    
    // Diagnostics: warn if assets stall more than 6s
    setTimeout(() => {
      if (window.sprReady !== true || window.bgReady !== true) {
        console.warn('Assets still not ready after 6000ms', { sprReady: window.sprReady, bgReady: window.bgReady });
        try { toggleDebug(true); } catch(_) {}
      }
    }, 6000);
// Toggle debug via keyboard (F3 or 'd') and mobile button
    document.addEventListener('keydown', (e) => {
      if (e.key === 'F3' || e.key === 'f3' || e.key.toLowerCase() === 'd') toggleDebug();
    });
    const dbgBtn = document.getElementById('debugBtn');
    if (dbgBtn) dbgBtn.addEventListener('click', () => toggleDebug());
document.getElementById('overlay').addEventListener('click', (e) => { if (state === 'dead') reset(); });
canvas.addEventListener('pointerdown', jump);

    ['touchstart','touchmove','touchend','gesturestart'].forEach(ev => { window.addEventListener(ev, (e) => { if (e.target === canvas || (e.target.closest && e.target.closest('#game'))) e.preventDefault(); }, { passive: false }); });

    Promise.all([ new Promise(res => { sprite.onload = () => { window.sprReady = true; res(); }; sprite.onerror = (e) => { window.sprReady = 'error'; console.error('Sprite failed to load', e); res(); }; }), new Promise(res => { if (bgReady) res(); else bgImg.onload = () => { bgReady = true; res(); }; }) ]).then(() => { resizeCanvas(); reset(); loop(); });
  </script>

<script>
  (function(){
    var ov = document.getElementById('overlay');
    if (ov) { ov.addEventListener('click', function(e){ if (e.target && e.target.id === 'overlay') { try { if (typeof reset==='function') reset(); } catch(_){} } }); }
  })();
</script>


  <div id="debugHud" class="debugHud hidden"></div>
  <div id="debugBadge" class="debugBadge hidden">DEBUG ON</div>

</body>
</html>
